"use strict";(self.webpackChunkprogrammierung=self.webpackChunkprogrammierung||[]).push([[3770],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=r.createContext({}),c=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(o.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=i,g=u["".concat(o,".").concat(m)]||u[m]||d[m]||a;return t?r.createElement(g,l(l({ref:n},p),{},{components:t})):r.createElement(g,l({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,l=new Array(a);l[0]=u;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var c=2;c<a;c++)l[c]=t[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},758:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=t(7462),i=(t(7294),t(3905));const a={title:"Generische Programmierung",description:"",sidebar_position:270,tags:[]},l=void 0,s={unversionedId:"documentation/generics",id:"documentation/generics",title:"Generische Programmierung",description:"",source:"@site/docs/documentation/generics.md",sourceDirName:"documentation",slug:"/documentation/generics",permalink:"/programming/documentation/generics",draft:!1,editUrl:"https://github.com/appenmaier/programming/tree/main/docs/documentation/generics.md",tags:[],version:"current",sidebarPosition:270,frontMatter:{title:"Generische Programmierung",description:"",sidebar_position:270,tags:[]},sidebar:"documentationSidebar",previous:{title:"Innere Klassen (Inner Classes)",permalink:"/programming/documentation/inner-classes"},next:{title:"Assoziativspeicher (Maps)",permalink:"/programming/documentation/maps"}},o={},c=[{value:"Generische Klassen ohne Java Generics",id:"generische-klassen-ohne-java-generics",level:2},{value:"Generische Klassen mit Java Generics",id:"generische-klassen-mit-java-generics",level:2},{value:"Generische Methoden mit Java Generics",id:"generische-methoden-mit-java-generics",level:2},{value:"Namensrichtlinien f\xfcr Typparameter",id:"namensrichtlinien-f\xfcr-typparameter",level:2},{value:"Varianz",id:"varianz",level:2}],p={toc:c};function d(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Quellcode sollte generell so allgemein bzw. generisch geschrieben werden, dass er f\xfcr unterschiedliche Datenstrukturen und Datentypen verwendet werden kann. Das Ziel der generischen Programmierung ist die Entwicklung von wiederverwendbarem Code. In Java\nverwendet man das Konzept der generischen Datentypen, also Klassen, die mit verschiedene Datentypen verwendet werden k\xf6nnen."),(0,i.kt)("h2",{id:"generische-klassen-ohne-java-generics"},"Generische Klassen ohne Java Generics"),(0,i.kt)("p",null,"Auch ohne Java Generics kann in Java mit Hilfe der Klasse ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," generisch programmiert werden. Der Nachteil besteht darin, dass durch den Upcast einer beliebigen Klasse auf die Klasse ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," die spezifischen Methoden der Klasse nicht mehr verwendet werden\nk\xf6nnen und der dadurch notwendige Downcast zu Laufzeitfehlern f\xfchren kann. "),(0,i.kt)("p",null,"Die Klasse ",(0,i.kt)("inlineCode",{parentName:"p"},"Box")," erm\xf6glicht das Speichern einer beliebig typisierten Information."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class Box {\n\n    private Object content;\n    public void set(Object content) { this.content = content; }\n    public Object get() { return content; }\n\n}\n")),(0,i.kt)("p",null,"In der main-Methode der Startklasse wird zun\xe4chst eine ganze Zahl in einer Box gespeichert und anschlie\xdfend wieder ausgelesen. Die Umwandlung der ganzen Zahl in eine Zeichenkette f\xfchrt erst zur Laufzeit zu einem Fehler."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class MainClass {\n\n    public static void main(String[] args) {\n        Box box = new Box();\n        box.set(5);\n        String i = (String) box.get(); // Laufzeitfehler\n    }\n\n}\n")),(0,i.kt)("h2",{id:"generische-klassen-mit-java-generics"},"Generische Klassen mit Java Generics"),(0,i.kt)("p",null,"Klassen und Methoden k\xf6nnen in Java mit Typen parametrisiert werden. Diese werden durch spitze Klammern ",(0,i.kt)("inlineCode",{parentName:"p"},"<>")," gekennzeichnet und stellen Platzhalter f\xfcr konkrete Datentypen dar. Beim Kompilieren werden alle generischen Informationen vollst\xe4ndig entfernt und\ndurch die konkreten Datentypen ersetzt. Durch die dadurch vorhandene statische Typsicherheit k\xf6nnen Laufzeitfehler verhindert und Fehler bereits beim Kompilieren entdeckt werden."),(0,i.kt)("p",null,"Die generische Klasse ",(0,i.kt)("inlineCode",{parentName:"p"},"GenericBox<T>")," erm\xf6glicht das Speichern einer beliebig typisierten Information mit Hilfe des Typparameters ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class GenericBox<T> {\n\n    private T content;\n    public void set(T content) { this.content = content; }\n    public T get() { return content; }\n\n}\n")),(0,i.kt)("p",null,"In der main-Methode der Startklasse wird zun\xe4chst eine ganze Zahl in einer generischen Box gespeichert und anschlie\xdfend wieder ausgelesen. Die Umwandlung der ganzen Zahl in eine Zeichenkette f\xfchrt aufgrund der statischen Typsicherheit zu einem\nKompilierungsfehler."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class MainClass {\n\n    public static void main(String[] args) {\n        GenericBox<Integer> genericBox = new GenericBox<>();\n        genericBox.set(5);\n        String i = genericBox.get(); // Kompilierungsfehler\n    }\n\n}\n")),(0,i.kt)("admonition",{title:"Hinweis",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Die Typisierung kann entweder explizit oder implizit \xfcber den Diamantenoperator ",(0,i.kt)("inlineCode",{parentName:"p"},"<>")," erfolgen.")),(0,i.kt)("h2",{id:"generische-methoden-mit-java-generics"},"Generische Methoden mit Java Generics"),(0,i.kt)("p",null,"Die generische Methode ",(0,i.kt)("inlineCode",{parentName:"p"},"<T> getIndex(T, T[])")," gibt den Index eines beliebig typisierten gesuchten Wertes innerhalb eines gleichtypisierten Feldes zur\xfcck."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class MainClass {\n\n    public static void main(String[] args) {\n        System.out.println(getIndex(5, new Integer[] { 3, 5, 2, 4, 1 }));\n    }\n\n    public static <T> int getIndex(T value, T[] values) {\n        for (int i = 0; i < values.length; i++) {\n            if (values[i].equals(value)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n}\n")),(0,i.kt)("h2",{id:"namensrichtlinien-f\xfcr-typparameter"},"Namensrichtlinien f\xfcr Typparameter"),(0,i.kt)("p",null,"Um den Einsatzbereich von Typparameteren in generischen Klassen und Methoden kenntlich zu machen, sollte man festgelegte Zeichen verwenden."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Typparameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Einsatzbereich"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"T, U, V, W..."),(0,i.kt)("td",{parentName:"tr",align:null},"Datentyp (Type)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"E"),(0,i.kt)("td",{parentName:"tr",align:null},"Element einer Datensammlung (Element)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"K"),(0,i.kt)("td",{parentName:"tr",align:null},"Schl\xfcssel eines Assoziativspeichers (Key)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"V"),(0,i.kt)("td",{parentName:"tr",align:null},"Wert eines Assoziativspeichers (Value)")))),(0,i.kt)("h2",{id:"varianz"},"Varianz"),(0,i.kt)("p",null,"Typparameter k\xf6nnen gar nicht (",(0,i.kt)("strong",{parentName:"p"},"Bivarianz"),"), nach oben (",(0,i.kt)("strong",{parentName:"p"},"Kovarianz"),"), nach unten (",(0,i.kt)("strong",{parentName:"p"},"Kontravarianz"),"), oder sowohl nach oben als auch nach unten (",(0,i.kt)("strong",{parentName:"p"},"Invarianz"),") eingeschr\xe4nkt werden. Zus\xe4tzlich erm\xf6glicht der Wildcard-Typ ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," bei parametrisierten Typen die\nAngabe eines unbestimmten Typs. "),(0,i.kt)("p",null,"Die generische Klasse ",(0,i.kt)("inlineCode",{parentName:"p"},"GenericBox<T>")," erm\xf6glicht das Speichern einer beliebig typisierten Information."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class GenericBox<T> {\n\n    private T content;\n    public void set(T content) { this.content = content; }\n    public T get() { return content; }\n\n}\n")),(0,i.kt)("p",null,"Die Drei Klassen ",(0,i.kt)("inlineCode",{parentName:"p"},"Above"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Center")," und ",(0,i.kt)("inlineCode",{parentName:"p"},"Below")," bilden eine Generalisierungshierarchie ab, wobei die Klasse ",(0,i.kt)("inlineCode",{parentName:"p"},"Below")," eine Unterklasse der Klasse ",(0,i.kt)("inlineCode",{parentName:"p"},"Center")," und diese wiederum eine Unterklasse der Klasse ",(0,i.kt)("inlineCode",{parentName:"p"},"Above")," darstellt."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class Above {}\npublic class Center extends Above {}\npublic class Below extends Center {}\n")),(0,i.kt)("p",null,"In der main-methode der Startklasse werden verschiedene generische Boxen unterschiedlich deklariert und anschlie\xdfend initialisiert."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class MainClass {\n\n    public static void main(String[] args) {\n        GenericBox<?> bivariant;\n        bivariant = new GenericBox<Above>();\n        bivariant = new GenericBox<Center>();\n        bivariant = new GenericBox<Below>();\n\n        GenericBox<? extends Center> covariant;\n        covariant = new GenericBox<Above>(); // Kompilierungsfehler\n        covariant = new GenericBox<Center>();\n        covariant = new GenericBox<Below>();\n\n        GenericBox<? super Center> contravariant;\n        contravariant = new GenericBox<Above>();\n        contravariant = new GenericBox<Center>();\n        contravariant = new GenericBox<Below>(); // Kompilierungsfehler\n\n        GenericBox<Center> invariant;\n        invariant = new GenericBox<Above>(); // Kompilierungsfehler\n        invariant = new GenericBox<Center>();\n        invariant = new GenericBox<Below>(); // Kompilierungsfehler\n    }\n\n}\n")))}d.isMDXComponent=!0}}]);