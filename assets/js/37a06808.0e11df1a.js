"use strict";(self.webpackChunkprogrammierung=self.webpackChunkprogrammierung||[]).push([[6345],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>c});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=a.createContext({}),o=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=o(e.components);return a.createElement(d.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,d=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=o(t),c=r,k=m["".concat(d,".").concat(c)]||m[c]||p[c]||s;return t?a.createElement(k,i(i({ref:n},u),{},{components:t})):a.createElement(k,i({ref:n},u))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,i=new Array(s);i[0]=m;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var o=2;o<s;o++)i[o]=t[o];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2665:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>o});var a=t(7462),r=(t(7294),t(3905));const s={title:"Innere Klassen (Inner Classes)",description:"",sidebar_position:260,tags:[]},i=void 0,l={unversionedId:"documentation/inner-classes",id:"documentation/inner-classes",title:"Innere Klassen (Inner Classes)",description:"",source:"@site/docs/documentation/inner-classes.md",sourceDirName:"documentation",slug:"/documentation/inner-classes",permalink:"/programming/documentation/inner-classes",draft:!1,editUrl:"https://github.com/appenmaier/programming/tree/main/docs/documentation/inner-classes.md",tags:[],version:"current",sidebarPosition:260,frontMatter:{title:"Innere Klassen (Inner Classes)",description:"",sidebar_position:260,tags:[]},sidebar:"documentationSidebar",previous:{title:"Datenklassen (Records)",permalink:"/programming/documentation/records"},next:{title:"Generische Programmierung",permalink:"/programming/documentation/generics"}},d={},o=[{value:"Geschachtelte Klassen (Nested Classes)",id:"geschachtelte-klassen-nested-classes",level:2},{value:"Elementklassen (Member Classes)",id:"elementklassen-member-classes",level:2},{value:"Lokale Klassen",id:"lokale-klassen",level:2},{value:"Anonyme Klassen",id:"anonyme-klassen",level:2},{value:"Lambda-Ausdr\xfccke",id:"lambda-ausdr\xfccke",level:2},{value:"Syntaxvarianten",id:"syntaxvarianten",level:2},{value:"Methodenreferenzen",id:"methodenreferenzen",level:2}],u={toc:o};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Java bietet die M\xf6glichkeit, Klassen und Schnittstellen zu verschachteln. Das Ziel von inneren Klassen ist eine Definition von Hilfsklassen m\xf6glichst nahe an der Stelle, wo sie gebraucht werden. Beispiele f\xfcr Hilfsklassen sind Ausnahmeklassen, Komparatoren und\nEreignisbehandler. Alle bisherigen Klassen werden auch als ",(0,r.kt)("strong",{parentName:"p"},"\xe4u\xdferer Klassen")," bzw. ",(0,r.kt)("strong",{parentName:"p"},"Top-Level-Klassen")," bezeichnet."),(0,r.kt)("h2",{id:"geschachtelte-klassen-nested-classes"},"Geschachtelte Klassen (Nested Classes)"),(0,r.kt)("p",null,"Geschachtelte Klassen sind Top-Level-Klassen, die zur Strukturierung des Namensraumes in anderen Top-Level-Klassen definiert sind. Ein Namensraum ist die vollst\xe4ndige Pfadangabe zur Klasse (z.B. ",(0,r.kt)("inlineCode",{parentName:"p"},"java.lang"),"). Geschachtelte Klassen m\xfcssen statisch definiert\nwerden und sind daher im eigentlichen Sinne keine richtigen inneren Klassen."),(0,r.kt)("p",null,"Zun\xe4chst wird die \xe4u\xdfere Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"OuterClass")," samt der geschachtelten Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"InnerClass")," definiert."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class OuterClass {\n\n    public static class InnerClass{ }\n    \n}\n")),(0,r.kt)("p",null,"In der main-Methode der Startklasse kann die innere Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"InnerClass")," nur durch Angabe des vollst\xe4ndigen Namensraumes verwendet werden, was die Angabe der \xe4u\xdferer Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"OuterClass")," miteinschlie\xdft."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class MainClass {\n\n    public static void main(String[] args) {\n        OuterClass o = new OuterClass;\n        OuterClass.InnerClass i = new OuterClass.InnerClass();\n    }\n\n}\n")),(0,r.kt)("h2",{id:"elementklassen-member-classes"},"Elementklassen (Member Classes)"),(0,r.kt)("p",null,"Objekte von Elementklassen sind immer mit einem Objekt der umgebenden Klasse verbunden. Dies erm\xf6glicht die Umsetzung von Kompositionen (siehe ",(0,r.kt)("a",{parentName:"p",href:"/programming/documentation/uml/class-diagrams"},"Klassendiagramme")," - Darstellung von Assoziationen). Sie haben Zugriff auf alle Variablen\nund Methoden der sie umgebenden Klasse und d\xfcrfen keine statischen Elemente enthalten."),(0,r.kt)("p",null,"Zun\xe4chst wird die \xe4u\xdfere Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"OuterClass")," samt der Elementklasse ",(0,r.kt)("inlineCode",{parentName:"p"},"InnerClass")," definiert. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class OuterClass {\n\n    public class InnerClass{ }\n    \n}\n")),(0,r.kt)("p",null,"In der main-Methode der Startklasse kann ein Objekt der Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"InnerClass")," nur auf ein bestehendes Objekt der Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"OuterClass")," erzeugt werden."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class MainClass {\n\n    public static void main(String[] args) {\n        OuterClass o = new OuterClass();\n        OuterClass.InnerClass i = new OuterClass.InnerClass(); // Kompilierungsfehler\n        OuterClass.InnerClass i = o.new OuterClass.InnerClass();\n    }\n\n}\n")),(0,r.kt)("h2",{id:"lokale-klassen"},"Lokale Klassen"),(0,r.kt)("p",null,"Lokale Klassen werden innerhalb einer Methode definiert und k\xf6nnen auch nur dort verwendet werden. Sie d\xfcrfen nicht als ",(0,r.kt)("inlineCode",{parentName:"p"},"public"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"protected"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," oder ",(0,r.kt)("inlineCode",{parentName:"p"},"static")," definiert werden, d\xfcrfen keine statischen Elemente enthalten und k\xf6nnen nur die mit ",(0,r.kt)("inlineCode",{parentName:"p"},"final"),"\nmarkierten Variablen und Parameter der umgebenden Methode verwenden."),(0,r.kt)("p",null,"Zun\xe4chst wird die Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Qux")," samt der Methode ",(0,r.kt)("inlineCode",{parentName:"p"},"void quux(String)"),"definiert."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public interface Qux {\n\n    void quux(String s);\n\n}\n")),(0,r.kt)("p",null,"Die Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," soll die Verwenderklasse der Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Qux")," darstellen."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class Foo {\n\n    public static void bar(String s, Qux q) {\n        q.quux(s);\n    }\n\n}\n")),(0,r.kt)("p",null,"In der main-Methode der Startklasse soll die Methode ",(0,r.kt)("inlineCode",{parentName:"p"},"void bar(String, Qux)")," der Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," aufgerufen werden, wof\xfcr eine konkrete Implementierung der Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Qux")," ben\xf6tigt wird. Die Implementierung erfolgt in Form der lokalen Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"LocalClass"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class MainClass {\n\n    public static void main(String[] args) {\n        class LocalClass implements Qux {\n            @Override\n            public void quux(String s) {\n                System.out.println(s);\n            }\n        }\n        \n        LocalClass l = new LocalClass();\n        Foo.bar("Winter is Coming", l);\n    }\n  \n}\n')),(0,r.kt)("h2",{id:"anonyme-klassen"},"Anonyme Klassen"),(0,r.kt)("p",null,"Anonyme Klassen besitzen im Gegensatz zu lokalen Klassen keinen Namen und werden innerhalb eines Ausdrucks definiert und instanziiert; Klassendeklaration und Objekterzeugung sind also in einem Sprachkonstrukt vereint. Wird als Datentyp eine Schnittstelle\nben\xf6tigt, implementiert die anonyme Klasse diese Schnittstelle, wird als Datentyp eine Klasse ben\xf6tigt, so wird die anonyme Klasse daraus abgeleitet."),(0,r.kt)("p",null,"Zun\xe4chst wird die Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Qux")," samt der Methode ",(0,r.kt)("inlineCode",{parentName:"p"},"void quux(String)"),"definiert."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public interface Qux {\n\n    void quux(String s);\n\n}\n")),(0,r.kt)("p",null,"Die Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," soll die Verwenderklasse der Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Qux")," darstellen."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class Foo {\n\n    public static void bar(String s, Qux q) {\n        q.quux(s);\n    }\n\n}\n")),(0,r.kt)("p",null,"In der main-Methode der Startklasse soll die Methode ",(0,r.kt)("inlineCode",{parentName:"p"},"void bar(String, Qux)")," der Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," aufgerufen werden, wof\xfcr eine konkrete Implementierung der Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Qux")," ben\xf6tigt wird. Die Implementierung erfolgt in Form einer anonymen Klasse."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class MainClass {\n\n    public static void main(String[] args) {\n        Foo.bar("Winter is Coming", new Qux() {\n            @Override\n            public void quux(String s) {\n                System.out.println(s);\n            } \n        });\n    }\n\n}\n')),(0,r.kt)("h2",{id:"lambda-ausdr\xfccke"},"Lambda-Ausdr\xfccke"),(0,r.kt)("p",null,"Lambda-Ausdr\xfccke sind anonyme Funktionen, die nur \xfcber ihre Referenz angesprochen werden k\xf6nnen. Die Methodenparameter und der Methodenk\xf6rper werden getrennt vom Pfeiloperator ",(0,r.kt)("inlineCode",{parentName:"p"},"->")," notiert. Voraussetzung f\xfcr den Einsatz eines Lambda-Ausdrucks ist eine\nfunktionale Schnittstelle, also eine Schnittstelle, die \xfcber genau eine Methode verf\xfcgt."),(0,r.kt)("p",null,"Zun\xe4chst wird die Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Qux")," samt der Methode ",(0,r.kt)("inlineCode",{parentName:"p"},"quux(String)"),"definiert."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public interface Qux {\n\n    void quux(String s);\n\n}\n")),(0,r.kt)("p",null,"Die Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," soll die Verwenderklasse der Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Qux")," darstellen."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class Foo {\n\n    public static void bar(String s, Qux q) {\n        q.quux(s);\n    }\n\n}\n")),(0,r.kt)("p",null,"In der main-Methode der Startklasse soll die Methode ",(0,r.kt)("inlineCode",{parentName:"p"},"bar(String, Qux)")," der Klasse ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," aufgerufen werden, wof\xfcr eine konkrete Implementierung der Schnittstelle ",(0,r.kt)("inlineCode",{parentName:"p"},"Qux")," ben\xf6tigt wird. Die Implementierung erfolgt in Form eines Lambda-Ausdrucks."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class MainClass {\n\n    public static void main(String[] args) {\n        Foo.bar("Winter is Coming", s -> System.out.println(s));\n    }\n\n}\n')),(0,r.kt)("h2",{id:"syntaxvarianten"},"Syntaxvarianten"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Bei keinem oder mehreren Methodenparametern m\xfcssen diese in runden Klammern angegeben werden, bei genau einem Methodenparameter k\xf6nnen die runden Klammern weggelassen werden"),(0,r.kt)("li",{parentName:"ul"},"Besteht der Methodenk\xf6rper aus mehreren Anweisungen, m\xfcssen diese in geschweiften Klammern angegeben werden, bei genau einer Anweisung k\xf6nnen die geschweiften Klammern weggelassen werden"),(0,r.kt)("li",{parentName:"ul"},"Besteht der Methodenk\xf6rper aus genau einer Anweisung, kann das Semikolon am Anweisungsende weggelassen werden, ist die Anweisung eine return-Anweisung, kann auch das ",(0,r.kt)("inlineCode",{parentName:"li"},"return")," weggelassen werden")),(0,r.kt)("h2",{id:"methodenreferenzen"},"Methodenreferenzen"),(0,r.kt)("p",null,"Lambda-Ausdr\xfccke, bei denen die referenzierte Methode von den Parametertypen und vom R\xfcckgabetyp genau auf die zu implementierende Methode passt, k\xf6nnen als Methodenreferenz dargestellt werden. Bei einer Methodenreferenz wird die Klasse bzw. die Referenz auf\nder linken Seite mit Hilfe zweier Doppelpunkte vom Methodennamen auf der recht Seite getrennt."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class MainClass {\n\n    public static void main(String[] args) {\n        Foo.bar("Winter is Coming", s -> System.out.println(s)); // Lambda-Ausdruck\n        Foo.bar("Winter is Coming", System.out::println); // Methodenreferenz\n    }\n\n}\n')))}p.isMDXComponent=!0}}]);